// lz4js-pure 280524
function hashU32(r){return r=(r|=0)+2127912214+(r<<12)|0,-1252372727^(r=(r=(r=(r^=-949894596^r>>>19)+374761393+(r<<5)|0)+-744332180^r<<9)+-42973499+(r<<3)|0)^r>>>16}function readU64(r,e){return r[e++]|r[e++]<<8|r[e++]<<16|r[e++]<<24|r[e++]<<32|r[e++]<<40|r[e++]<<48|r[e]<<56}function readU32(r,e){return r[e++]|r[e++]<<8|r[e++]<<16|r[e]<<24}function writeU32(r,e,s){r[e++]=255&s,r[e++]=s>>8&255,r[e++]=s>>16&255,r[e]=s>>24&255}const minMatch=4,matchSearchLimit=12,minTrailingLitterals=5,skipTrigger=6,mlBits=4,mlMask=(1<<mlBits)-1,runBits=4,runMask=15,fdContentSize=8,fdBlockChksum=16,fdVersion=64,fdVersionMask=192,bsUncompressed=2147483648,bsShift=4,bsMask=7;function compressBound(r){return r+r/255+16|0}function decompressBound(r){if(407708164!==readU32(r,0))throw new Error("invalid magic number");let e=4;const s=r[e++];if((s&fdVersionMask)!==fdVersion)throw new Error("incompatible descriptor version "+(s&fdVersionMask));if(s&fdContentSize)return readU64(r,e);const t=!!(s&fdBlockChksum),n=r[e++]>>bsShift&bsMask,o={4:65536,5:262144,6:1048576,7:4194304}[n];if(void 0===o)throw new Error(`invalid block size bsIdx: ${n}`);e++;let i=0;for(;;){let s=readU32(r,e);if(e+=4,s&bsUncompressed?(s&=~bsUncompressed,i+=s):s>0&&(i+=o),0===s)return i;t&&(e+=4),e+=s}}function decompressBlock(r,e,s,t,n){const o=s+t;for(;s<o;){const t=r[s++];let i=t>>4;if(i>0){if(15===i){let e;do{e=r[s++],i+=e}while(255===e)}const t=s+i;for(;s<t;)e[n++]=r[s++]}if(s>=o)break;let c=15&t;const f=r[s++]|r[s++]<<8;if(15===c){let e;do{e=r[s++],c+=e}while(255===e)}if(c+=minMatch,1===f)e.fill(0|e[n-1],n,n+c),n+=c;else if(f>c){const r=n-f,s=r+c;for(let t=r;t<s;++t)e[n++]=0|e[t]}else{const r=n-f,s=c/f|0,t=e.subarray(r,n);for(let r=0;r<s;++r)e.set(t,n),n+=f;const o=r+c-s*f;for(let s=r;s<o;++s)e[n++]=0|e[s]}}return n}function compressBlock(r,e,s,t,n){const o=t+s;let i=0,c=s,f=3+(1<<skipTrigger);for(;s<=o-matchSearchLimit;){const t=readU32(r,s);let a=hashU32(t)>>>0;a=(a>>16^a)>>>0&65535;let l=n[a]-1;if(n[a]=s+1,l<0||s-l>>>16>0||readU32(r,l)!==t){s+=f++>>skipTrigger;continue}f=3+(1<<skipTrigger);const m=s-c,u=s-l;l+=minMatch;let d=s+=minMatch;for(;s<o-minTrailingLitterals&&r[s]===r[l];)s++,l++;d=s-d;const k=d<mlMask?d:mlMask;if(m>=runMask){e[i++]=(runMask<<mlBits)+k;let r=m-runMask;for(;r>=255;)e[i++]=255,r-=255;e[i++]=r}else e[i++]=(m<<mlBits)+k;for(let s=c;s<c+m;s++)e[i++]=r[s];if(e[i++]=u,e[i++]=u>>8,d>=mlMask){let r=d-mlMask;for(;r>=255;)e[i++]=255,r-=255;e[i++]=r}c=s}if(0===c)return 0;const a=o-c;if(a>=runMask){e[i++]=runMask<<mlBits;let r=a-runMask;for(;r>=255;)e[i++]=255,r-=255;e[i++]=r}else e[i++]=a<<mlBits;for(s=c;s<o;)e[i++]=r[s++];return i}export function compress(r){const e=compressBound(r.length),s=new Uint8Array(e);s.set(new Uint8Array([4,34,77,24,96,112,115]),0);let t=7;const n=4194304,o=new Uint32Array(65536);let i=r.length,c=0;const f=new Uint8Array(5<<20);for(;i>0;){const e=i>n?n:i,a=compressBlock(r,f,c,e,o);a>e||0===a?(writeU32(s,t,2147483648|e),t+=4,s.set(r.subarray(c,c+e),t),t+=e):(writeU32(s,t,a),t+=4,s.set(f.subarray(0,a),t),t+=a),c+=e,i-=e}return t+=4,s.subarray(0,t)}export function decompress(r){let e=0,s=4;const t=r[s++];if((t&fdVersionMask)!==fdVersion)throw new Error("incompatible descriptor version");const n=!!(t&fdBlockChksum),o=!!(t&fdContentSize);s++;const i=decompressBound(r),c=new Uint8Array(i);o&&(s+=8),s++;let f=readU32(r,s);s+=4;do{n&&(s+=4),f&bsUncompressed?(f&=~bsUncompressed,c.set(r.subarray(s,s+f),e),e+=f,s+=f):(e=decompressBlock(r,c,s,f,e),s+=f),f=readU32(r,s),s+=4}while(0!==f);return c.subarray(0,e)}export const codec=()=>({compress:r=>{const e=compress(r.buffer);return Buffer.from(e)},decompress:r=>{const e=decompress(r);return Buffer.from(e)}});